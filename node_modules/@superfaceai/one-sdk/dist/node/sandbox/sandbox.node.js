"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSandbox = void 0;
var vm2_1 = require("vm2");
var lib_1 = require("../../lib");
var DEBUG_NAMESPACE = 'sandbox';
var NodeSandbox = /** @class */ (function () {
    function NodeSandbox() {
    }
    NodeSandbox.prototype.evalScript = function (config, js, stdlib, logger, variableDefinitions) {
        var vm = new vm2_1.VM({
            sandbox: __assign({ std: stdlib }, variableDefinitions),
            compiler: 'javascript',
            wasm: false,
            eval: false,
            timeout: config.sandboxTimeout,
            fixAsync: true,
        });
        var log = logger === null || logger === void 0 ? void 0 : logger.log(DEBUG_NAMESPACE);
        // Defensively delete global objects
        // These deletions mostly don't protect, but produce "nicer" errors for the user
        vm.run("\n      'use strict'\n\n      delete global.require // Forbidden\n      delete global.process // Forbidden\n      delete global.console // Forbidden/useless\n\n      delete global.setTimeout\n      delete global.setInterval\n      delete global.setImmediate\n      delete global.clearTimeout\n      delete global.clearInterval\n      delete global.clearImmediate\n      // delete global.String\n      // delete global.Number\n      // delete global.Buffer\n      // delete global.Boolean\n      // delete global.Array\n      // delete global.Date\n      // delete global.RegExp // Forbidden - needed for object literals to work, weirdly\n      delete global.Function // Can be restored by taking .constructor of any function, but the VM protection kicks in\n      // delete global.Object\n      delete global.VMError // Useless\n      delete global.Proxy // Forbidden\n      delete global.Reflect // Forbidden\n      // delete global.Promise // Forbidden, also VM protection - BUT needed for object literals to work, weirdly\n      delete global.Symbol // Forbidden\n\n      delete global.eval // Forbidden, also VM protects\n      delete global.WebAssembly // Forbidden, also VM protects\n      delete global.AsyncFunction // Forbidden, also VM protects\n      delete global.SharedArrayBuffer // Just in case\n      ");
        log === null || log === void 0 ? void 0 : log('Evaluating:', js);
        var result = vm.run("\n        'use strict';\n        const vmResult = " + js + "\n        ;vmResult");
        var resultVm2Fixed = this.vm2ExtraArrayKeysFixup(result);
        log === null || log === void 0 ? void 0 : log('Result: %O', resultVm2Fixed);
        return resultVm2Fixed;
    };
    NodeSandbox.prototype.vm2ExtraArrayKeysFixup = function (value) {
        var e_1, _a;
        if (typeof value !== 'object') {
            return value;
        }
        if (lib_1.isNone(value)) {
            return value;
        }
        if (Buffer.isBuffer(value) ||
            value instanceof ArrayBuffer ||
            lib_1.isClassInstance(value) ||
            Symbol.iterator in value ||
            Symbol.asyncIterator in value) {
            return value;
        }
        if (Array.isArray(value)) {
            var newArray = [];
            for (var i = 0; i < value.length; i += 1) {
                newArray[i] = this.vm2ExtraArrayKeysFixup(value[i]);
            }
            return newArray;
        }
        var newObject = {};
        var currentObject = value;
        try {
            for (var _b = __values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                newObject[key] = this.vm2ExtraArrayKeysFixup(currentObject[key]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newObject;
    };
    return NodeSandbox;
}());
exports.NodeSandbox = NodeSandbox;
//# sourceMappingURL=sandbox.node.js.map