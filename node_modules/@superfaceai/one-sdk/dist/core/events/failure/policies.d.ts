import type { Backoff } from './backoff';
import type { ExecutionFailure, ExecutionInfo, ExecutionSuccess, UsecaseInfo } from './policy';
import { FailurePolicy } from './policy';
import type { ExecutionResolution, FailureResolution, SuccessResolution } from './resolution';
export declare class FailurePolicyRouter {
    private readonly instantiateFailurePolicy;
    private readonly priority;
    private currentProvider;
    private allowFailover;
    private readonly providersOfUseCase;
    constructor(instantiateFailurePolicy: (provider: string) => FailurePolicy, priority: string[]);
    getCurrentProvider(): string | undefined;
    setCurrentProvider(provider: string): void;
    setAllowFailover(allowFailover: boolean): void;
    private attemptSwitch;
    private attemptFailover;
    private attemptFailoverRestore;
    private handleFailover;
    beforeExecution(info: ExecutionInfo): ExecutionResolution;
    afterFailure(info: ExecutionFailure): FailureResolution;
    afterSuccess(info: ExecutionSuccess): SuccessResolution;
    reset(): void;
}
/** Simple policy which aborts on the first failure */
export declare class AbortPolicy extends FailurePolicy {
    constructor(usecaseInfo: UsecaseInfo);
    beforeExecution(_info: ExecutionInfo): ExecutionResolution;
    afterFailure(info: ExecutionFailure): FailureResolution;
    afterSuccess(_info: ExecutionSuccess): SuccessResolution;
    reset(): void;
}
/** Simple retry policy with exponential backoff */
export declare class RetryPolicy extends FailurePolicy {
    readonly maxContiguousRetries: number;
    readonly requestTimeout: number;
    private readonly backoff;
    static DEFAULT_MAX_CONTIGUOUS_RETRIES: number;
    static DEFAULT_REQUEST_TIMEOUT: number;
    /**
     * Counts the length of the current streak of actions
     *
     * Negative means failures, positive means successes
     */
    private streak;
    /** Counts the current balace of .up() and .down() calls to backoff */
    private balance;
    private lastCallTime;
    constructor(usecaseInfo: UsecaseInfo, maxContiguousRetries: number, requestTimeout: number, backoff: Backoff);
    beforeExecution(info: ExecutionInfo): ExecutionResolution;
    afterFailure(info: ExecutionFailure): FailureResolution;
    afterSuccess(info: ExecutionSuccess): SuccessResolution;
    reset(): void;
}
/**
 * Circuit breaker pattern
 *
 * The circuit breaker starts closed.
 * On a failure, an exponential backoff ramps up to the configured threshold. On success, the backoff ramps down the same way.
 *
 * If a streak of failures reaches the configured threshold the breaker trips. In this state, the breaker will abort any outgoing request
 * until a configured timeout is reached. After this timeout, the breaker goes into half-open state where any failure will trip it again.
 *
 * If a successful execution is detected from half-open state, the breaker closes again and is in the same state as at the beginning.
 */
export declare class CircuitBreakerPolicy extends FailurePolicy {
    /** Reset timeout in milliseconds */
    private readonly resetTimeout;
    static DEFAULT_OPEN_TIME: number;
    private readonly inner;
    private state;
    private openTime;
    constructor(usecaseInfo: UsecaseInfo, 
    /** Number of contiguous failures before the breaker trips */
    failureThreshold: number, 
    /** Reset timeout in milliseconds */
    resetTimeout: number, requestTimeout: number, backoff: Backoff);
    beforeExecution(info: ExecutionInfo): ExecutionResolution;
    afterFailure(info: ExecutionFailure): FailureResolution;
    afterSuccess(info: ExecutionSuccess): SuccessResolution;
    private open;
    private halfOpen;
    private close;
    reset(): void;
}
