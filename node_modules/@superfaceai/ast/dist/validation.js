"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAssert = exports.preparePrepareIs = void 0;
var ajv_1 = __importDefault(require("ajv"));
var ajv_formats_1 = __importDefault(require("ajv-formats"));
var error_1 = require("./error");
var ajv = new ajv_1.default({ allowUnionTypes: true });
(0, ajv_formats_1.default)(ajv);
function preparePrepareIs(schema) {
    ajv.addSchema(schema);
    return function (id) {
        return function (object) {
            if (ajv.validate(id, object)) {
                return true;
            }
            return false;
        };
    };
}
exports.preparePrepareIs = preparePrepareIs;
function ajvErrorToMessage(ajvError, value) {
    switch (ajvError.keyword) {
        case 'maxItems':
            return "must have at most ".concat(ajvError.params.limit, " items");
        case 'minItems':
            return "must have at least ".concat(ajvError.params.limit, " items");
        case 'maxLength':
            return "must be at most ".concat(ajvError.params.limit, " characters long");
        case 'minLength':
            return "must be at least ".concat(ajvError.params.limit, " characters long");
        case 'maxProperties':
            return "must have at most ".concat(ajvError.params.limit, " properties");
        case 'minProperties':
            return "must have at least ".concat(ajvError.params.limit, " properties");
        case 'additionalItems':
            return "must not have more than ".concat(ajvError.params.limit, " items");
        case 'additionalProperties':
            return "must not have additional property \"".concat(ajvError.params.additionalProperty, "\"");
        case 'dependencies':
            return "must have ".concat(ajvError.params.depsCount, " properties");
        case 'format':
            return "must be a ".concat(ajvError.params.format);
        case 'maximum':
            return "must be at most ".concat(ajvError.params.limit);
        case 'minimum':
            return "must be at least ".concat(ajvError.params.limit);
        case 'exclusiveMaximum':
            return "must be less than ".concat(ajvError.params.limit);
        case 'exclusiveMinimum':
            return "must be greater than ".concat(ajvError.params.limit);
        case 'multipleOf':
            return "must be a multiple of ".concat(ajvError.params.multipleOf);
        case 'pattern':
            return "must match pattern \"".concat(ajvError.params.pattern, "\"");
        case 'required':
            return "must have required property \"".concat(ajvError.params.missingProperty, "\"");
        case 'propertyNames':
            return "must have property \"".concat(ajvError.params.propertyName, "\"");
        case 'type':
            return "must be ".concat(ajvError.params.type, ", received ").concat(typeof value);
        case 'anyOf':
            return 'must match one of the valid types';
        case 'enum':
            return "invalid enum value, expected one of: ".concat(ajvError.params.allowedValues.join(', '), ", received \"").concat(String(value), "\"");
        default:
            console.log(ajvError);
            return "must be valid";
    }
}
function digIntoInput(input, path) {
    var e_1, _a;
    var current = input;
    try {
        for (var path_1 = __values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
            var key = path_1_1.value;
            if (current === undefined) {
                return undefined;
            }
            if (typeof current === 'string' ||
                typeof current === 'number' ||
                typeof current === 'boolean') {
                return current;
            }
            if (typeof current === 'object') {
                if (current === null) {
                    return current;
                }
            }
            current = current[key];
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return current;
}
function prepareAssert(schema, key) {
    ajv.addSchema(schema, key);
    return function assert(input) {
        if (!ajv.validate(schema, input)) {
            var errorEntries = ajv.errors.map(function (ajvError) {
                var path = ajvError.instancePath
                    .split('/')
                    .filter(function (value) { return value !== ''; });
                return [ajvErrorToMessage(ajvError, digIntoInput(input, path)), path];
            });
            throw new error_1.AssertionError(errorEntries, input);
        }
    };
}
exports.prepareAssert = prepareAssert;
//# sourceMappingURL=validation.js.map