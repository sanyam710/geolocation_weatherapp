/// <reference types="node" />
import type { Readable } from 'stream';
import type { IBinaryData, IBinaryDataMeta, IDataContainer, IDestructible, IInitializable } from '../../interfaces';
export declare class StreamReader {
    private stream;
    private buffer;
    private ended;
    private pendingReadResolve;
    private dataCallback;
    private endCallback;
    constructor(stream: NodeJS.ReadableStream);
    private hook;
    private unhook;
    private onData;
    private onEnd;
    private waitForData;
    private notifyData;
    read(size?: number): Promise<Buffer>;
    toStream(): Readable;
}
export declare class FileContainer implements IDataContainer, IBinaryDataMeta, IInitializable, IDestructible {
    readonly path: string;
    private handle;
    private streamReader;
    private _size;
    constructor(path: string);
    get name(): string | undefined;
    get mimetype(): string | undefined;
    get size(): number;
    read(size?: number): Promise<Buffer>;
    initialize(): Promise<void>;
    destroy(): Promise<void>;
    toStream(): NodeJS.ReadableStream;
}
export declare class StreamContainer implements IDataContainer {
    private streamReader;
    constructor(stream: NodeJS.ReadableStream);
    read(size?: number): Promise<Buffer>;
    toStream(): NodeJS.ReadableStream;
}
export declare type BinaryDataOptions = {
    /** filename for files or URL for sockets */
    name?: string;
    mimetype?: string;
};
export declare class BinaryData implements IBinaryData, IBinaryDataMeta, IDestructible, IInitializable {
    private dataContainer;
    private buffer;
    private _name;
    private _mimetype;
    static fromPath(path: string, options?: BinaryDataOptions): BinaryData;
    static fromStream(stream: NodeJS.ReadableStream, options?: BinaryDataOptions): BinaryData;
    private constructor();
    /**
     * @returns filename for files or URL for sockets
     */
    get name(): string | undefined;
    /**
     * Set name for files or URL for sockets
     */
    set name(value: string | undefined);
    /**
     * @returns MIME type
     */
    get mimetype(): string | undefined;
    set mimetype(value: string | undefined);
    /**
     * @returns Size if known in bytes
     */
    get size(): number | undefined;
    initialize(): Promise<void>;
    destroy(): Promise<void>;
    private fillBuffer;
    private consumeBuffer;
    /**
     * Reads data and stores them in internal buffer for later consumption
     *
     * @param [size=1] Specifies how much data to peek
     * @returns Peeked data as Buffer
     */
    peek(size?: number): Promise<Buffer>;
    /**
     * Reads data
     * @param [size=1] Specifies how much data to read
     * @returns Read data as Buffer
     */
    read(size?: number): Promise<Buffer>;
    /**
     * Reads data from stream and returns chunk once filled with requested size
     *
     * @param chunkSize Specifies how many bytes should be in one chunk, except last which can be smaller
     * @returns Async interable returning one chunk
     */
    chunkBy(chunkSize: number): AsyncIterable<Buffer>;
    /**
     * Reads data from Stream until the stream is closed
     *
     * @param [chunkSize=16000] specifies how much data in bytes to read in one chunk
     * @returns Read data as Buffer
     */
    getAllData(chunkSize?: number): Promise<Buffer>;
    /**
     * Returns stream to read BinaryData
     *
     * @returns Readable instance
     */
    toStream(): NodeJS.ReadableStream;
}
