"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedError = exports.JessieError = exports.MappedHTTPError = exports.HTTPError = exports.MapASTError = exports.MapInterpreterErrorBase = void 0;
var lib_1 = require("../../lib");
var MapInterpreterErrorBase = /** @class */ (function (_super) {
    __extends(MapInterpreterErrorBase, _super);
    function MapInterpreterErrorBase(kind, message, metadata) {
        var _this = _super.call(this, kind, message) || this;
        _this.kind = kind;
        _this.message = message;
        _this.metadata = metadata;
        return _this;
    }
    Object.defineProperty(MapInterpreterErrorBase.prototype, "astPath", {
        get: function () {
            var _this = this;
            var _a, _b;
            if (this.path) {
                return this.path;
            }
            if (!((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.ast) || !((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.node)) {
                return undefined;
            }
            var dfs = function (current, path) {
                var e_1, _a;
                var _b;
                if (path === void 0) { path = []; }
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                var newPath = function (key) {
                    return Array.isArray(current)
                        ? __spreadArray(__spreadArray([], __read(path.slice(0, path.length - 1))), [
                            path[path.length - 1] + "[" + key + "]",
                        ]) : __spreadArray(__spreadArray([], __read(path)), [key]);
                };
                try {
                    for (var _c = __values(Object.entries(current)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
                        if (value === ((_b = _this.metadata) === null || _b === void 0 ? void 0 : _b.node)) {
                            return newPath(key);
                        }
                        else {
                            if (typeof value === 'object') {
                                var next = dfs(value, newPath(key));
                                if (next !== undefined) {
                                    return next;
                                }
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return undefined;
            };
            this.path = dfs(this.metadata.ast);
            return this.path;
        },
        enumerable: false,
        configurable: true
    });
    MapInterpreterErrorBase.prototype.toString = function () {
        var _a, _b;
        return [
            this.kind + ": " + this.message,
            this.astPath ? "AST Path: " + this.astPath.join('.') : undefined,
            ((_b = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.location)
                ? "Original Map Location: Line " + this.metadata.node.location.start.line + ", column " + this.metadata.node.location.start.column
                : undefined,
        ]
            .filter(function (line) { return line !== undefined && line !== ''; })
            .join('\n');
    };
    return MapInterpreterErrorBase;
}(lib_1.ErrorBase));
exports.MapInterpreterErrorBase = MapInterpreterErrorBase;
var MapASTError = /** @class */ (function (_super) {
    __extends(MapASTError, _super);
    function MapASTError(message, metadata) {
        var _this = _super.call(this, 'MapASTError', message, metadata) || this;
        _this.message = message;
        _this.metadata = metadata;
        _this.name = 'MapASTError';
        return _this;
    }
    return MapASTError;
}(MapInterpreterErrorBase));
exports.MapASTError = MapASTError;
var HTTPError = /** @class */ (function (_super) {
    __extends(HTTPError, _super);
    function HTTPError(message, metadata, statusCode, request, response) {
        var _this = _super.call(this, 'HTTPError', message, metadata) || this;
        _this.message = message;
        _this.metadata = metadata;
        _this.statusCode = statusCode;
        _this.request = request;
        _this.response = response;
        _this.name = 'HTTPError';
        return _this;
    }
    return HTTPError;
}(MapInterpreterErrorBase));
exports.HTTPError = HTTPError;
var MappedHTTPError = /** @class */ (function (_super) {
    __extends(MappedHTTPError, _super);
    function MappedHTTPError(message, metadata, statusCode, properties) {
        var _this = _super.call(this, 'MappedHTTPError', message, metadata) || this;
        _this.message = message;
        _this.metadata = metadata;
        _this.statusCode = statusCode;
        _this.properties = properties;
        _this.name = 'MappedHTTPError';
        return _this;
    }
    MappedHTTPError.prototype.toString = function () {
        var _a, _b;
        return [
            this.kind + ": " + this.message,
            this.properties !== undefined
                ? 'Properties: ' + JSON.stringify(this.properties, undefined, 2)
                : undefined,
            this.astPath ? "AST Path: " + this.astPath.join('.') : undefined,
            ((_b = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.location)
                ? "Original Map Location: Line " + this.metadata.node.location.start.line + ", column " + this.metadata.node.location.start.column
                : undefined,
        ]
            .filter(function (line) { return line !== undefined && line !== ''; })
            .join('\n');
    };
    return MappedHTTPError;
}(MapInterpreterErrorBase));
exports.MappedHTTPError = MappedHTTPError;
var JessieError = /** @class */ (function (_super) {
    __extends(JessieError, _super);
    function JessieError(message, originalError, metadata) {
        var _this = _super.call(this, 'JessieError', message) || this;
        _this.message = message;
        _this.originalError = originalError;
        _this.metadata = metadata;
        _this.name = 'JessieError';
        return _this;
    }
    JessieError.prototype.toString = function () {
        var _a, _b;
        return [
            this.kind + ": " + this.message,
            this.originalError.toString(),
            this.astPath ? "AST Path: " + this.astPath.join('.') : undefined,
            ((_b = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.location)
                ? "Original Map Location: Line " + this.metadata.node.location.start.line + ", column " + this.metadata.node.location.start.column
                : undefined,
        ]
            .filter(function (line) { return line !== undefined && line !== ''; })
            .join('\n');
    };
    return JessieError;
}(MapInterpreterErrorBase));
exports.JessieError = JessieError;
var MappedError = /** @class */ (function (_super) {
    __extends(MappedError, _super);
    function MappedError(message, metadata, properties) {
        var _this = _super.call(this, 'MappedError', message, metadata) || this;
        _this.message = message;
        _this.metadata = metadata;
        _this.properties = properties;
        _this.name = 'MappedError';
        return _this;
    }
    MappedError.prototype.toString = function () {
        var _a, _b;
        return [
            this.kind + ": " + this.message,
            this.properties !== undefined
                ? 'Properties: ' + JSON.stringify(this.properties, undefined, 2)
                : undefined,
            this.astPath ? "AST Path: " + this.astPath.join('.') : undefined,
            ((_b = (_a = this.metadata) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.location)
                ? "Original Map Location: Line " + this.metadata.node.location.start.line + ", column " + this.metadata.node.location.start.column
                : undefined,
        ]
            .filter(function (line) { return Boolean(line); })
            .join('\n');
    };
    return MappedError;
}(MapInterpreterErrorBase));
exports.MappedError = MappedError;
//# sourceMappingURL=map-interpreter.errors.js.map