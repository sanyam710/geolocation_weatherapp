"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unknownProviderInfoError = exports.unknownBindResponseError = exports.bindResponseError = exports.invalidMapASTResponseError = exports.invalidProviderResponseError = exports.invalidResponseError = exports.unexpectedDigestValue = exports.missingPartOfDigestHeader = exports.digestHeaderNotFound = exports.invalidHTTPMapValueType = exports.profileIdsDoNotMatchError = exports.providersDoNotMatchError = exports.referencedFileNotFoundError = exports.localProviderAndRemoteMapError = exports.usecaseNotFoundError = exports.unsupportedContentType = exports.apiKeyInBodyError = exports.missingSecurityValuesError = exports.invalidPathReplacementError = exports.invalidBackoffEntryError = exports.invalidSecurityValuesError = exports.securityNotFoundError = exports.serviceNotFoundError = exports.invalidProfileError = exports.unconfiguredProviderError = exports.unconfiguredProviderInPriorityError = exports.providersNotSetError = exports.profileProviderNotFoundError = exports.profileNotFoundError = exports.variantMismatchError = exports.versionMismatchError = exports.invalidVersionError = exports.invalidIdentifierIdError = exports.unableToResolveProfileError = exports.profileFileNotFoundError = exports.profileNotInstalledError = exports.sourceFileExtensionFoundError = exports.unsupportedFileExtensionError = exports.noConfiguredProviderError = exports.unableToResolveProviderError = exports.superJsonReadError = exports.superJsonFormatError = exports.superJsonNotAFileError = exports.superJsonNotFoundError = exports.superJsonNotDefinedError = void 0;
var ast_1 = require("@superfaceai/ast");
var lib_1 = require("../../lib");
var registry_1 = require("../registry");
function superJsonNotDefinedError(callerName) {
    return new lib_1.SDKExecutionError("Super.json must be defined to call \"" + callerName + "\"", [], [
        'Define "superJson" property in SuperfaceClient constructor',
        'Add super.json config file with @superfaceai/cli package',
    ]);
}
exports.superJsonNotDefinedError = superJsonNotDefinedError;
function superJsonNotFoundError(path, error) {
    var errorMessage = ["super.json not found in \"" + path + "\""];
    if (error !== undefined) {
        errorMessage.push(error.toString());
    }
    return new lib_1.SDKExecutionError('Unable to find super.json', errorMessage, []);
}
exports.superJsonNotFoundError = superJsonNotFoundError;
function superJsonNotAFileError(path) {
    return new lib_1.SDKExecutionError('super.json is not a file', ["\"" + path + "\" is not a file"], []);
}
exports.superJsonNotAFileError = superJsonNotAFileError;
function superJsonFormatError(error) {
    return new lib_1.SDKExecutionError('super.json format is invalid', [error.toString()], []);
}
exports.superJsonFormatError = superJsonFormatError;
function superJsonReadError(error) {
    return new lib_1.SDKExecutionError('Unable to read super.json', [error.toString()], []);
}
exports.superJsonReadError = superJsonReadError;
function unableToResolveProviderError() {
    return new lib_1.SDKExecutionError('Unable to resolve provider', [
        'Provider must be specified in "perform" method call. Optionally, profileId and super.json can be used to obtain provider for profile.',
    ], [
        'Check that a provider is configured in "perform" call',
        'Optionally, check that a provider is configured for a profile in super.json',
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.unableToResolveProviderError = unableToResolveProviderError;
function noConfiguredProviderError(profileId) {
    return new lib_1.SDKExecutionError("No configured provider found for profile: " + profileId, [
        "Profile \"" + profileId + "\" needs at least one configured provider for automatic provider selection",
    ], [
        'Check that a provider is configured for a profile in "perform" call',
        "Optionally, check that a provider is configured for a profile in super.json -> profiles[\"" + profileId + "\"].providers",
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.noConfiguredProviderError = noConfiguredProviderError;
function unsupportedFileExtensionError(filepath, correctExtension) {
    return new lib_1.SDKExecutionError("File path " + filepath + " contains unsupported extension.", [], ["Use file with " + correctExtension + " extension."]);
}
exports.unsupportedFileExtensionError = unsupportedFileExtensionError;
function sourceFileExtensionFoundError(extension) {
    return new lib_1.SDKExecutionError(extension + " extension found.", [], [extension + " files need to be compiled with Superface CLI."]);
}
exports.sourceFileExtensionFoundError = sourceFileExtensionFoundError;
function profileNotInstalledError(profileId) {
    return new lib_1.SDKExecutionError("Profile not installed: " + profileId, [], [
        "Check that the profile is installed in super.json -> profiles[\"" + profileId + "\"]",
        "Profile can be installed using the superface cli tool: `superface install " + profileId + "`",
    ]);
}
exports.profileNotInstalledError = profileNotInstalledError;
function profileFileNotFoundError(file, profileId) {
    return new lib_1.SDKExecutionError("Profile file at path does not exist: " + file, [
        "Profile \"" + profileId + "\" specifies a file path \"" + file + "\" in super.json",
        'but this path does not exist or is not accessible',
    ], [
        "Check that path in super.json -> profiles[\"" + profileId + "\"].file exists and is accessible",
        'Paths in super.json are either absolute or relative to the location of super.json',
    ]);
}
exports.profileFileNotFoundError = profileFileNotFoundError;
function unableToResolveProfileError(profileId) {
    return new lib_1.SDKExecutionError("Profile \"" + profileId + "\" not found in super.json or version is not defined in \"getProfile\"", [
        "To resolve correct profile \"" + profileId + "\" must be defined in super.json or profile version must be specified in \"getProfile\" function",
    ], [
        "Profile can be installed to local super.json using the superface cli tool: `superface install " + profileId + "`",
        "Optionally full version eg. 1.0.0 can be passed to \"getProfile\" in format `" + profileId + "@version` or as an obejct: { id: " + profileId + ", version: version}",
    ]);
}
exports.unableToResolveProfileError = unableToResolveProfileError;
function invalidIdentifierIdError(identifier, problematicPart) {
    return new lib_1.SDKExecutionError(problematicPart + " \"" + identifier + "\" is not a valid lowercase .", [], ['Use valid idetifier']);
}
exports.invalidIdentifierIdError = invalidIdentifierIdError;
function invalidVersionError(completeVersion, problematicPart) {
    return new lib_1.SDKExecutionError("Version \"" + completeVersion + "\" is not valid version. \"" + problematicPart + "\" is missing or not a number", [
        "Version \"" + completeVersion + "\" is not valid version in format major.minor.patch eg. \"1.0.0\". \"" + problematicPart + "\" is missing or not a number",
    ], [
        'Pass valid version string in format major.minor.patch-label (-label is optional) eg. "1.0.0" or "1.2.3-test"',
    ]);
}
exports.invalidVersionError = invalidVersionError;
function versionMismatchError(superJsonVersion, getProfileVersion) {
    return new lib_1.SDKExecutionError("Version from super.json (" + superJsonVersion + ") and getProfile (" + getProfileVersion + ") does not match.", ['If version in super.json and in "getProfile" is used they must match'], ['Use version either in super.json or in "getProfile"']);
}
exports.versionMismatchError = versionMismatchError;
function variantMismatchError(astVariant, passedVariant) {
    return new lib_1.SDKExecutionError("Variant from compiled map (" + (astVariant !== null && astVariant !== void 0 ? astVariant : 'undefined') + ") and passed variant (" + (passedVariant !== null && passedVariant !== void 0 ? passedVariant : 'undefined') + ") does not match.", ['If variant in map and passed variant is used, they must match'], []);
}
exports.variantMismatchError = variantMismatchError;
function profileNotFoundError(profileName) {
    return new lib_1.SDKExecutionError("Profile \"" + profileName + "\" not found in super.json", [], []);
}
exports.profileNotFoundError = profileNotFoundError;
function profileProviderNotFoundError(profileId, providerName) {
    return new lib_1.SDKExecutionError("Provider \"" + providerName + "\" not found for profile \"" + profileId + "\" in super.json", [], [
        "Optionally, check that a provider is configured for a profile in super.json -> profiles[\"" + profileId + "\"].providers",
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.profileProviderNotFoundError = profileProviderNotFoundError;
function providersNotSetError(profileName) {
    return new lib_1.SDKExecutionError("Unable to set priority for \"" + profileName + "\"", ["Providers not set for profile \"" + profileName + "\""], ["Make sure profile " + profileName + " has configured providers."]);
}
exports.providersNotSetError = providersNotSetError;
function unconfiguredProviderInPriorityError(profileId, priority, providers) {
    return new lib_1.SDKExecutionError("Priority array of profile: " + profileId + " contains unconfigured provider", [
        "Profile \"" + profileId + "\" specifies a provider array [" + priority.join(', ') + "] in super.json",
        "but there are only these providers configured [" + providers.join(', ') + "]",
    ], [
        "Check that providers [" + priority.join(', ') + "] are configured for profile \"" + profileId + "\"",
        'Paths in super.json are either absolute or relative to the location of super.json',
    ]);
}
exports.unconfiguredProviderInPriorityError = unconfiguredProviderInPriorityError;
function unconfiguredProviderError(providerName) {
    return new lib_1.SDKExecutionError("Provider not configured: " + providerName, ["Provider \"" + providerName + "\" was not configured in super.json"], [
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.unconfiguredProviderError = unconfiguredProviderError;
function invalidProfileError(profileId) {
    return new lib_1.SDKExecutionError("Invalid profile \"" + profileId + "\"", [], [
        'Check that the profile is installed in super.json -> profiles or that the url is valid',
        'Profiles can be installed using the superface cli tool: `superface install --help` for more info',
    ]);
}
exports.invalidProfileError = invalidProfileError;
function serviceNotFoundError(serviceId, providerName, defaultService) {
    var hints = [];
    if (defaultService) {
        hints = [
            'This appears to be an error in the provider definition. Make sure that the defaultService in provider definition refers to an existing service id',
        ];
    }
    return new lib_1.SDKExecutionError("Service not found: " + serviceId, ["Service \"" + serviceId + "\" for provider \"" + providerName + "\" was not found"], hints);
}
exports.serviceNotFoundError = serviceNotFoundError;
function securityNotFoundError(providerName, definedSchemes, values) {
    return new lib_1.SDKExecutionError("Could not find security scheme for security value with id \"" + values.id + "\"", [
        "The provider definition for \"" + providerName + "\" defines " +
            (definedSchemes.length > 0
                ? "these security schemes: " + definedSchemes.join(', ')
                : 'no security schemes'),
        "but a secret value was provided for security scheme: " + values.id,
    ], [
        "Check that every entry id in super.json -> providers[\"" + providerName + "\"].security refers to an existing security scheme",
        "Make sure any configuration overrides in code for provider \"" + providerName + "\" refer to an existing security scheme",
    ]);
}
exports.securityNotFoundError = securityNotFoundError;
function invalidSecurityValuesError(providerName, type, id, valueKeys, requiredKeys) {
    return new lib_1.SDKExecutionError("Invalid security values for given " + type + " scheme: " + id, [
        "The provided security values with id \"" + id + "\" have keys: " + valueKeys.join(', '),
        "but " + type + " scheme requires: " + requiredKeys.join(', '),
    ], [
        "Check that the entry with id \"" + id + "\" in super.json -> providers[\"" + providerName + "\"].security refers to the correct security scheme",
        "Make sure any configuration overrides in code for provider \"" + providerName + "\" refer to the correct security scheme",
    ]);
}
exports.invalidSecurityValuesError = invalidSecurityValuesError;
function invalidBackoffEntryError(kind) {
    return new lib_1.SDKExecutionError("Invalid backoff entry format: \"" + kind + "\"", [
        "Property \"kind\" in retryPolicy.backoff object has unexpected value \"" + kind + "\"",
        "Property \"kind\" in super.json [profile].providers.[provider].defaults.[usecase].retryPolicy.backoff with value \"" + kind + "\" is not valid",
    ], [
        'Check your super.json',
        "Check property \"kind\" in [profile].providers.[provider].defaults.[usecase].retryPolicy.backoff with value \"" + kind + "\"",
        "Change value of property \"kind\" in retryPolicy.backoff to one of possible values: " + Object.values(ast_1.BackoffKind).join(', '),
    ]);
}
exports.invalidBackoffEntryError = invalidBackoffEntryError;
function invalidPathReplacementError(invalid, url, all, available) {
    return new lib_1.SDKExecutionError("Missing or mistyped values for URL path replacement: " + invalid.join(', '), [
        "Trying to replace path keys for url: " + url,
        all.length > 0
            ? "Found these path keys: " + all.join(', ')
            : 'Found no path keys',
        available.length > 0
            ? "But only found these variables with supported types: " + available.join(', ')
            : 'But found no variables with supported types',
    ], [
        'Make sure the url path variable refers to an available string, number or boolean variable',
        'Consider introducing a new variable with the correct name and desired value',
    ]);
}
exports.invalidPathReplacementError = invalidPathReplacementError;
function missingSecurityValuesError(id) {
    return new lib_1.SDKExecutionError("Security values for security scheme not found: " + id, [
        "Security values for scheme \"" + id + "\" are required by the map",
        'but they were not provided to the sdk',
    ], [
        "Make sure that the security scheme \"" + id + "\" exists in provider definition",
        "Check that either super.json or provider configuration provides security values for the \"" + id + "\" security scheme",
    ]);
}
exports.missingSecurityValuesError = missingSecurityValuesError;
function apiKeyInBodyError(valueLocation, bodyType) {
    return new lib_1.SDKExecutionError('ApiKey in body can be used only on object.', ["Actual " + valueLocation + " is " + bodyType], []);
}
exports.apiKeyInBodyError = apiKeyInBodyError;
function unsupportedContentType(contentType, supportedTypes) {
    return new lib_1.SDKExecutionError("Content type not supported: " + contentType, [
        "Requested content type \"" + contentType + "\"",
        "Supported content types: " + supportedTypes.join(', '),
    ], []);
}
exports.unsupportedContentType = unsupportedContentType;
function usecaseNotFoundError(name, usecases) {
    return new lib_1.SDKExecutionError("Usecase not found: \"" + name + "\"", ["Available usecases: " + usecases.join(', ')], []);
}
exports.usecaseNotFoundError = usecaseNotFoundError;
function localProviderAndRemoteMapError(providerName, profileId) {
    return new lib_1.SDKExecutionError("Unable to use local provider " + providerName + " and remote profile provider (map)", [
        "Super.json settings: " + profileId + ".providers." + providerName,
        "Super.json settings providers." + providerName,
    ], [
        'Use local provider and profile provider (map)',
        'Use remote provider and profile provider (map)',
        'Use remote provider and local profile provider (map)',
    ]);
}
exports.localProviderAndRemoteMapError = localProviderAndRemoteMapError;
function referencedFileNotFoundError(fileName, extensions) {
    return new lib_1.SDKExecutionError("File referenced in super.json not found: " + fileName, __spreadArray(__spreadArray([
        'Tried to open files:'
    ], __read(extensions.map(function (extension) { return "\t" + fileName + extension; }))), [
        'but none of them were found.',
    ]), []);
}
exports.referencedFileNotFoundError = referencedFileNotFoundError;
function providersDoNotMatchError(mapOrJsonProvider, configProvider, source) {
    return new lib_1.SDKExecutionError("Provider name in " + source + " does not match provider name in configuration", [
        "Map file specifies provider \"" + mapOrJsonProvider + "\".",
        "Configuration specifies provider \"" + configProvider + "\".",
    ], []);
}
exports.providersDoNotMatchError = providersDoNotMatchError;
function profileIdsDoNotMatchError(mapProfileId, configProfileId) {
    return new lib_1.SDKExecutionError("Profile id (" + mapProfileId + ") in map does not match profile id (" + configProfileId + ") in configuration", [
        "Map file specifies profile id \"" + mapProfileId + "\".",
        "Configuration specifies profile id \"" + configProfileId + "\".",
    ], ['Pass profile id that matches to profile id in map or provide correct map']);
}
exports.profileIdsDoNotMatchError = profileIdsDoNotMatchError;
function invalidHTTPMapValueType(kind, key, type) {
    return new lib_1.SDKExecutionError("Invalid HTTP " + kind + " value type: " + key, ["Value is of type " + type + " but string was expected"], ['Stringify value before passing it to the HTTP request']);
}
exports.invalidHTTPMapValueType = invalidHTTPMapValueType;
function digestHeaderNotFound(headerName, foundHeaders) {
    return new lib_1.SDKExecutionError("Digest auth failed, unable to extract digest values from response. Header \"" + headerName + "\" not found in response headers.", ["Found headers: " + foundHeaders.join(', ') + "."], [
        'Check API documentation if it specifies challenge header',
        'You can set challenge header in provider.json',
    ]);
}
exports.digestHeaderNotFound = digestHeaderNotFound;
function missingPartOfDigestHeader(headerName, header, part) {
    return new lib_1.SDKExecutionError("Digest auth failed, unable to extract digest values from response. Header \"" + headerName + "\" does not contain \"" + part + "\"", [
        "Header: \"" + headerName + "\" with content: \"" + header + "\" does not contain part specifing: \"" + part + "\"",
    ], []);
}
exports.missingPartOfDigestHeader = missingPartOfDigestHeader;
function unexpectedDigestValue(valueName, value, possibleValues) {
    return new lib_1.SDKExecutionError("Digest auth failed, parameter \"" + valueName + "\" has unexpected value: \"" + value + "\"", [
        "Digest auth failed, parameter \"" + valueName + "\" has unexpected value: \"" + value + "\". Supported values: " + possibleValues.join(', '),
    ], []);
}
exports.unexpectedDigestValue = unexpectedDigestValue;
function invalidResponseError(statusCode, error) {
    if (registry_1.isRegistryErrorBody(error)) {
        return new lib_1.SDKBindError("Registry call failed with status code: " + statusCode + " and error message: " + error.title, error.detail !== undefined ? [error.detail] : [], []);
    }
    return new lib_1.SDKBindError("Registry call failed with unexpected error: " + JSON.stringify(error), [], []);
}
exports.invalidResponseError = invalidResponseError;
// Bind errors
function invalidProviderResponseError(error) {
    if (error instanceof ast_1.AssertionError) {
        return new lib_1.SDKBindError('Bind call responded with invalid provider body', error.detailed().split('\n'), ['Received provider should be of type "ProviderJson"']);
    }
    return new lib_1.SDKBindError("Bind call response validation failed with unexpected error: " + JSON.stringify(error), [], []);
}
exports.invalidProviderResponseError = invalidProviderResponseError;
function invalidMapASTResponseError() {
    return new lib_1.SDKBindError('Bind call response did not contain valid map', [], []);
}
exports.invalidMapASTResponseError = invalidMapASTResponseError;
function bindResponseError(_a) {
    var statusCode = _a.statusCode, profileId = _a.profileId, provider = _a.provider, title = _a.title, detail = _a.detail, mapVariant = _a.mapVariant, mapRevision = _a.mapRevision, apiUrl = _a.apiUrl;
    var longLines = [];
    if (detail !== undefined) {
        longLines.push(detail);
    }
    if (mapVariant !== undefined) {
        longLines.push("Looking for map variant \"" + mapVariant + "\"");
    }
    if (mapRevision !== undefined) {
        longLines.push("Looking for map revision \"" + mapRevision + "\"");
    }
    return new lib_1.SDKBindError("Registry responded with status code " + statusCode + (title !== undefined ? " - " + title + "." : '.'), longLines, [
        provider !== undefined
            ? "Check if profile \"" + profileId + "\" can be used with provider \"" + provider + "\""
            : "Check if profile \"" + profileId + "\" can be used with selected provider.",
        "If you are using remote profile you can check informations about profile at \"" + new URL(profileId, apiUrl).href + "\"",
        "If you are trying to use remote profile check if profile \"" + profileId + "\" is published",
        'If you are using local profile you can use local map and provider to bypass the binding',
    ]);
}
exports.bindResponseError = bindResponseError;
function unknownBindResponseError(_a) {
    var statusCode = _a.statusCode, profileId = _a.profileId, body = _a.body, provider = _a.provider, mapVariant = _a.mapVariant, mapRevision = _a.mapRevision, apiUrl = _a.apiUrl;
    var longLines = [
        provider !== undefined
            ? "Error occured when binding profile \"" + profileId + "\" with provider \"" + provider + "\""
            : "Error occured when binding profile \"" + profileId + "\" with selected provider",
    ];
    if (mapVariant !== undefined) {
        longLines.push("Looking for map variant \"" + mapVariant + "\"");
    }
    if (mapRevision !== undefined) {
        longLines.push("Looking for map revision \"" + mapRevision + "\"");
    }
    return new lib_1.SDKBindError("Registry responded with status code " + statusCode + " and unexpected body " + String(body), longLines, [
        provider !== undefined
            ? "Check if profile \"" + profileId + "\" can be used with provider \"" + provider + "\""
            : "Check if profile \"" + profileId + "\" can be used with selected provider",
        "If you are using remote profile you can check informations about profile at \"" + new URL(profileId, apiUrl).href + "\"",
        "If you are trying to use remote profile check if profile \"" + profileId + "\" is published",
        'If you are using local profile you can use local map and provider to bypass the binding',
    ]);
}
exports.unknownBindResponseError = unknownBindResponseError;
function unknownProviderInfoError(_a) {
    var message = _a.message, provider = _a.provider, body = _a.body, statusCode = _a.statusCode;
    var longLines = [
        message,
        "Error occured when fetching info about provider \"" + provider + "\"",
    ];
    return new lib_1.SDKExecutionError("Registry responded with status code " + statusCode + " and unexpected body " + String(body), longLines, ["Check if provider \"" + provider + "\" is published"]);
}
exports.unknownProviderInfoError = unknownProviderInfoError;
//# sourceMappingURL=errors.helpers.js.map