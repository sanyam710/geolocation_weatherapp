"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircuitBreakerPolicy = exports.RetryPolicy = exports.AbortPolicy = exports.FailurePolicyRouter = void 0;
var lib_1 = require("../../../lib");
var policy_1 = require("./policy");
var FailurePolicyRouter = /** @class */ (function () {
    function FailurePolicyRouter(instantiateFailurePolicy, priority) {
        this.instantiateFailurePolicy = instantiateFailurePolicy;
        this.priority = priority;
        this.allowFailover = true;
        this.providersOfUseCase = Object.fromEntries(priority.map(function (provider) { return [provider, instantiateFailurePolicy(provider)]; }));
    }
    FailurePolicyRouter.prototype.getCurrentProvider = function () {
        return this.currentProvider;
    };
    FailurePolicyRouter.prototype.setCurrentProvider = function (provider) {
        // create a policy ad-hoc if a provider that hasn't been preconfigured was provided
        if (!(provider in this.providersOfUseCase)) {
            this.providersOfUseCase[provider] =
                this.instantiateFailurePolicy(provider);
        }
        this.currentProvider = provider;
    };
    FailurePolicyRouter.prototype.setAllowFailover = function (allowFailover) {
        this.allowFailover = allowFailover;
    };
    FailurePolicyRouter.prototype.attemptSwitch = function (info, providers, reason) {
        var _this = this;
        // find the first previous provider that doesn't abort
        var newProvider = providers.find(function (provider) {
            return _this.providersOfUseCase[provider].beforeExecution(info).kind ===
                'continue';
        });
        if (newProvider === undefined) {
            return undefined;
        }
        this.setCurrentProvider(newProvider);
        return { kind: 'switch-provider', provider: newProvider, reason: reason };
    };
    FailurePolicyRouter.prototype.attemptFailover = function (info, reason) {
        if (this.currentProvider === undefined) {
            throw new lib_1.UnexpectedError('Property currentProvider is not set in Router instance');
        }
        if (!this.allowFailover) {
            return undefined;
        }
        var previousProviders = this.priority.slice(this.priority.indexOf(this.currentProvider) + 1);
        return this.attemptSwitch(info, previousProviders, reason);
    };
    FailurePolicyRouter.prototype.attemptFailoverRestore = function (info) {
        var _this = this;
        if (this.currentProvider === undefined) {
            throw new lib_1.UnexpectedError('Property currentProvider is not set in Router instance');
        }
        if (!this.allowFailover || info.checkFailoverRestore !== true) {
            return undefined;
        }
        var previousProviders = this.priority
            .slice(0, this.priority.indexOf(this.currentProvider))
            .filter(
        // TODO: Temporary hack to avoid infinite switch loops
        // this needs to be solved globally
        function (provider) { return !(_this.providersOfUseCase[provider] instanceof AbortPolicy); });
        return this.attemptSwitch(info, previousProviders, policy_1.FailurePolicyReason.fromPolicyReason('Provider failover restore'));
    };
    FailurePolicyRouter.prototype.handleFailover = function (info, innerResolution) {
        if (innerResolution.kind === 'abort') {
            var failover = this.attemptFailover(info, innerResolution.reason);
            if (failover === undefined) {
                return {
                    kind: 'abort',
                    reason: innerResolution.reason.addPrefixMessage('No backup provider available'),
                };
            }
            return failover;
        }
        return innerResolution;
    };
    FailurePolicyRouter.prototype.beforeExecution = function (info) {
        if (this.currentProvider === undefined) {
            throw new lib_1.UnexpectedError('Property currentProvider is not set in Router instance');
        }
        var failoverRestore = this.attemptFailoverRestore(info);
        if (failoverRestore !== undefined) {
            return failoverRestore;
        }
        var innerResolution = this.providersOfUseCase[this.currentProvider].beforeExecution(info);
        return this.handleFailover(info, innerResolution);
    };
    FailurePolicyRouter.prototype.afterFailure = function (info) {
        if (this.currentProvider === undefined) {
            throw new lib_1.UnexpectedError('Property currentProvider is not set in Router instance');
        }
        var innerResolution = this.providersOfUseCase[this.currentProvider].afterFailure(info);
        return this.handleFailover(__assign(__assign({}, info), { checkFailoverRestore: false }), innerResolution);
    };
    FailurePolicyRouter.prototype.afterSuccess = function (info) {
        if (this.currentProvider === undefined) {
            throw new lib_1.UnexpectedError('Property currentProvider is not set in Router instance');
        }
        return this.providersOfUseCase[this.currentProvider].afterSuccess(info);
    };
    FailurePolicyRouter.prototype.reset = function () {
        var e_1, _a;
        this.setCurrentProvider(this.priority[0]);
        try {
            for (var _b = __values(Object.values(this.providersOfUseCase)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var policy = _c.value;
                policy.reset();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return FailurePolicyRouter;
}());
exports.FailurePolicyRouter = FailurePolicyRouter;
/** Simple policy which aborts on the first failure */
var AbortPolicy = /** @class */ (function (_super) {
    __extends(AbortPolicy, _super);
    function AbortPolicy(usecaseInfo) {
        return _super.call(this, usecaseInfo) || this;
    }
    AbortPolicy.prototype.beforeExecution = function (_info) {
        return { kind: 'continue', timeout: 30000 };
    };
    AbortPolicy.prototype.afterFailure = function (info) {
        return {
            kind: 'abort',
            reason: policy_1.FailurePolicyReason.fromExecutionFailure(info),
        };
    };
    AbortPolicy.prototype.afterSuccess = function (_info) {
        return { kind: 'continue' };
    };
    AbortPolicy.prototype.reset = function () { };
    return AbortPolicy;
}(policy_1.FailurePolicy));
exports.AbortPolicy = AbortPolicy;
/** Simple retry policy with exponential backoff */
var RetryPolicy = /** @class */ (function (_super) {
    __extends(RetryPolicy, _super);
    function RetryPolicy(usecaseInfo, maxContiguousRetries, requestTimeout, backoff) {
        var _this = _super.call(this, usecaseInfo) || this;
        _this.maxContiguousRetries = maxContiguousRetries;
        _this.requestTimeout = requestTimeout;
        _this.backoff = backoff;
        _this.streak = 0;
        _this.balance = 0;
        _this.lastCallTime = 0;
        return _this;
    }
    RetryPolicy.prototype.beforeExecution = function (info) {
        // positive balance means no backoff
        if (this.balance >= 0) {
            return { kind: 'continue', timeout: this.requestTimeout };
        }
        // don't apply backoff if enough time has elapsed since then anyway
        var sinceLastCall = info.time - this.lastCallTime;
        var backoff = Math.max(0, this.backoff.current - sinceLastCall);
        return { kind: 'backoff', backoff: backoff, timeout: this.requestTimeout };
    };
    RetryPolicy.prototype.afterFailure = function (info) {
        if (info.kind === 'bind') {
            this.streak = -this.maxContiguousRetries;
        }
        // either reset to -1 or make the negative streak longer
        this.streak = Math.min(-1, this.streak - 1);
        this.lastCallTime = info.time;
        if (-this.streak > this.maxContiguousRetries) {
            // abort when we fail too much
            return {
                kind: 'abort',
                reason: policy_1.FailurePolicyReason.fromExecutionFailure(info).addPrefixMessage("Max (" + this.maxContiguousRetries + ") retries exceeded."),
            };
        }
        this.balance -= 1;
        this.backoff.up();
        // otherwise retry
        return { kind: 'retry' };
    };
    RetryPolicy.prototype.afterSuccess = function (info) {
        this.streak = Math.max(1, this.streak + 1);
        this.lastCallTime = info.time;
        if (this.balance >= 0) {
            return { kind: 'continue' };
        }
        // there is some backoff to lower from previous failures
        this.balance += 1;
        this.backoff.down();
        return { kind: 'continue' };
    };
    RetryPolicy.prototype.reset = function () {
        this.streak = 0;
        this.lastCallTime = 0;
        while (this.balance < 0) {
            this.backoff.down();
            this.balance += 1;
        }
    };
    RetryPolicy.DEFAULT_MAX_CONTIGUOUS_RETRIES = 5;
    RetryPolicy.DEFAULT_REQUEST_TIMEOUT = 30000;
    return RetryPolicy;
}(policy_1.FailurePolicy));
exports.RetryPolicy = RetryPolicy;
/**
 * Circuit breaker pattern
 *
 * The circuit breaker starts closed.
 * On a failure, an exponential backoff ramps up to the configured threshold. On success, the backoff ramps down the same way.
 *
 * If a streak of failures reaches the configured threshold the breaker trips. In this state, the breaker will abort any outgoing request
 * until a configured timeout is reached. After this timeout, the breaker goes into half-open state where any failure will trip it again.
 *
 * If a successful execution is detected from half-open state, the breaker closes again and is in the same state as at the beginning.
 */
var CircuitBreakerPolicy = /** @class */ (function (_super) {
    __extends(CircuitBreakerPolicy, _super);
    function CircuitBreakerPolicy(usecaseInfo, 
    /** Number of contiguous failures before the breaker trips */
    failureThreshold, 
    /** Reset timeout in milliseconds */
    resetTimeout, requestTimeout, backoff) {
        var _this = _super.call(this, usecaseInfo) || this;
        _this.resetTimeout = resetTimeout;
        _this.inner = new RetryPolicy(usecaseInfo, failureThreshold - 1, requestTimeout, backoff);
        _this.state = 'closed';
        _this.openTime = 0;
        return _this;
    }
    CircuitBreakerPolicy.prototype.beforeExecution = function (info) {
        if (this.state === 'open') {
            if (info.time >= this.openTime + this.resetTimeout) {
                this.halfOpen();
                return { kind: 'continue', timeout: this.inner.requestTimeout };
            }
            else {
                // TODO: more user friendly message
                return {
                    kind: 'abort',
                    reason: policy_1.FailurePolicyReason.fromPolicyReason('Circuit breaker is open'),
                };
            }
        }
        var innerResponse = this.inner.beforeExecution(info);
        if (innerResponse.kind === 'abort') {
            this.open(info.time);
            // TODO: more user friendly message
            return {
                kind: 'abort',
                reason: policy_1.FailurePolicyReason.fromPolicyReason('Circuit breaker is open'),
            };
        }
        return innerResponse;
    };
    CircuitBreakerPolicy.prototype.afterFailure = function (info) {
        if (this.state === 'half-open') {
            this.open(info.time);
            return {
                kind: 'abort',
                reason: policy_1.FailurePolicyReason.fromExecutionFailure(info).addPrefixMessage('Circuit breaker is open'),
            };
        }
        if (this.state === 'open') {
            throw new lib_1.UnexpectedError('Unreachable circuit breaker state');
        }
        var innerResponse = this.inner.afterFailure(info);
        if (innerResponse.kind === 'abort') {
            this.open(info.time);
            return {
                kind: 'abort',
                reason: policy_1.FailurePolicyReason.fromExecutionFailure(info).addPrefixMessage('Circuit breaker is open'),
            };
        }
        return innerResponse;
    };
    CircuitBreakerPolicy.prototype.afterSuccess = function (info) {
        if (this.state === 'half-open') {
            this.close();
        }
        if (this.state === 'open') {
            throw new lib_1.UnexpectedError('Unreachable');
        }
        return this.inner.afterSuccess(info);
    };
    CircuitBreakerPolicy.prototype.open = function (time) {
        this.state = 'open';
        this.inner.reset();
        this.openTime = time;
    };
    CircuitBreakerPolicy.prototype.halfOpen = function () {
        this.state = 'half-open';
    };
    CircuitBreakerPolicy.prototype.close = function () {
        this.state = 'closed';
    };
    CircuitBreakerPolicy.prototype.reset = function () {
        this.inner.reset();
        this.state = 'closed';
        this.openTime = 0;
    };
    CircuitBreakerPolicy.DEFAULT_OPEN_TIME = 30000;
    return CircuitBreakerPolicy;
}(policy_1.FailurePolicy));
exports.CircuitBreakerPolicy = CircuitBreakerPolicy;
//# sourceMappingURL=policies.js.map