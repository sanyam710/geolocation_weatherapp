import type { EventFilter, IEvents, ILogger, ITimers, LogFunction } from '../../interfaces';
import type { HttpResponse, IFetch, RequestParameters } from '../interpreter';
import type { UseCase } from '../usecase';
import type { HooksContext } from './failure/event-adapter';
import type { MapInterpreterEventAdapter } from './failure/map-interpreter-adapter';
import type { FailurePolicyReason } from './failure/policy';
declare type AsyncFunction = (...args: any[]) => Promise<any>;
declare type MaybePromise<T> = T | Promise<T>;
declare type ResolvedPromise<T> = T extends Promise<infer R> ? R : T;
export declare type InterceptableMetadata = {
    provider?: string;
    profile?: string;
    usecase?: string;
};
export declare type Interceptable = {
    metadata?: InterceptableMetadata;
    events?: Events;
};
declare type EventContextBase = {
    readonly time: Date;
    readonly usecase?: string;
    readonly profile?: string;
    readonly provider?: string;
};
export declare type BeforeHookResult<Target extends AsyncFunction> = MaybePromise<{
    kind: 'continue';
} | {
    kind: 'modify';
    newArgs: Parameters<Target>;
} | {
    kind: 'abort';
    newResult: ReturnType<Target>;
} | void>;
export declare type BeforeHook<EventContext extends EventContextBase, Target extends AsyncFunction> = (context: EventContext, args: Parameters<Target>) => BeforeHookResult<Target>;
export declare type AfterHookResult<Target extends AsyncFunction> = MaybePromise<{
    kind: 'continue';
} | {
    kind: 'modify';
    newResult: ReturnType<Target>;
} | {
    kind: 'retry';
    newArgs?: Parameters<Target>;
} | void>;
export declare type AfterHook<EventContext extends EventContextBase, Target extends AsyncFunction> = (context: EventContext, args: Parameters<Target>, result: ReturnType<Target>) => AfterHookResult<Target>;
export declare type BindContext = EventContextBase & {
    profile: string;
    usecase: string;
};
export declare type PerformContext = EventContextBase & {
    profile: string;
    usecase: string;
    provider: string;
};
export declare type ProviderSwitchContext = EventContextBase & {
    provider: string;
    toProvider?: string;
    profile: string;
    reason: FailurePolicyReason;
};
export declare type SuccessContext = EventContextBase & {
    profile: string;
    usecase: string;
    provider: string;
};
export declare type FailureContext = EventContextBase & {
    profile: string;
    usecase: string;
    provider: string;
};
export declare type AuthenticateContext = EventContextBase & {
    resourceRequest?: RequestParameters;
    previousResponse?: HttpResponse;
};
declare type VoidEventTypes = {
    failure: FailureContext;
    success: SuccessContext;
    'provider-switch': ProviderSwitchContext;
};
declare type VoidEventHook<EventContext extends EventContextBase> = (context: EventContext) => void;
declare type EventTypes = {
    perform: [
        InstanceType<typeof UseCase>['performBoundUsecase'],
        PerformContext
    ];
    fetch: [IFetch['fetch'], EventContextBase];
    'unhandled-http': [
        InstanceType<typeof MapInterpreterEventAdapter>['unhandledHttp'],
        EventContextBase
    ];
    'bind-and-perform': [
        InstanceType<typeof UseCase>['bindAndPerform'],
        BindContext
    ];
};
export declare type EventParams = {
    [K in keyof EventTypes as `pre-${K}`]: BeforeHook<EventTypes[K][1], EventTypes[K][0]>;
} & {
    [K in keyof EventTypes as `post-${K}`]: AfterHook<EventTypes[K][1], EventTypes[K][0]>;
} & {
    [K in keyof VoidEventTypes]: VoidEventHook<VoidEventTypes[K]>;
};
export declare class Events implements IEvents<EventParams> {
    timers: ITimers;
    hookContext: HooksContext;
    private listeners;
    log: LogFunction | undefined;
    constructor(timers: ITimers, logger?: ILogger);
    on<E extends keyof EventParams>(event: E, options: {
        priority: number;
        filter?: EventFilter;
    }, callback: EventParams[E]): void;
    emit<E extends keyof EventParams>(event: E, parameters: Parameters<EventParams[E]>): Promise<ResolvedPromise<ReturnType<EventParams[E]>>>;
}
export declare type InterceptPlacement = 'before' | 'after' | 'around';
declare const eventInterceptorMetadataDefaults: {
    placement: InterceptPlacement;
};
declare type EventMetadata<E extends keyof EventTypes> = Partial<typeof eventInterceptorMetadataDefaults> & {
    eventName: E;
};
export declare function eventInterceptor<E extends keyof EventTypes>(eventMetadata: EventMetadata<E>): (target: Interceptable, propertyKey: string, descriptor: TypedPropertyDescriptor<EventTypes[E][0]>) => PropertyDescriptor;
export {};
