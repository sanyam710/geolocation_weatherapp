"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricReporter = exports.hookMetrics = void 0;
var lib_1 = require("../../../lib");
var interpreter_1 = require("../../interpreter");
var utils_1 = require("./utils");
var DEBUG_NAMESPACE = 'metric-reporter';
// TODO: Make this better
function failurePolicyReasonToFailoverReason(reason) {
    if (reason.data.kind === 'failure') {
        if (reason.data.failure.kind === 'network') {
            switch (reason.data.failure.issue) {
                case 'dns':
                    return "NETWORK_ERROR_DNS" /* NETWORK_ERROR_DNS */;
                case 'timeout':
                    return "NETWORK_ERROR_TIMEOUT" /* NETWORK_ERROR_TIMEOUT */;
                case 'unsigned-ssl':
                    return "NETWORK_ERROR_SSL" /* NETWORK_ERROR_SSL */;
                case 'reject':
                    return "NETWORK_ERROR_CONNECTION" /* NETWORK_ERROR_CONNECTION */;
            }
        }
        else if (reason.data.failure.kind === 'request') {
            switch (reason.data.failure.issue) {
                case 'timeout':
                    return "REQUEST_ERROR_TIMEOUT" /* REQUEST_ERROR_TIMEOUT */;
                case 'abort':
                    return "REQUEST_ERROR_ABORT" /* REQUEST_ERROR_ABORT */;
            }
        }
        else {
            if (reason.data.failure.kind === 'http') {
                if (reason.data.failure.response.statusCode === 500) {
                    return "HTTP_ERROR_500" /* HTTP_ERROR_500 */;
                }
            }
        }
    }
    return "UNEXPECTED_ERROR" /* UNEXPECTED_ERROR */;
}
function hookMetrics(events, metricReporter) {
    events.on('success', { priority: 0 }, function (context) {
        metricReporter.reportEvent({
            eventType: 'PerformMetrics',
            profile: context.profile,
            success: true,
            provider: context.provider,
            occurredAt: context.time,
        });
        return { kind: 'continue' };
    });
    events.on('failure', { priority: 0 }, function (context) {
        metricReporter.reportEvent({
            eventType: 'PerformMetrics',
            profile: context.profile,
            success: false,
            provider: context.provider,
            occurredAt: context.time,
        });
        return { kind: 'continue' };
    });
    events.on('provider-switch', { priority: 1000 }, function (context) {
        metricReporter.reportEvent({
            eventType: 'ProviderChange',
            profile: context.profile,
            from: context.provider,
            to: context.toProvider,
            occurredAt: context.time,
            reasons: [{ reason: context.reason, occurredAt: context.time }],
        });
    });
}
exports.hookMetrics = hookMetrics;
var MetricReporter = /** @class */ (function () {
    function MetricReporter(config, timers, fetchInstance, crypto, superJson, logger) {
        this.config = config;
        this.timers = timers;
        this.fetchInstance = fetchInstance;
        this.performMetrics = [];
        if (config.metricDebounceTimeMax < config.metricDebounceTimeMin) {
            throw new lib_1.UnexpectedError("Value of metricDebounceTimeMax (" + config.metricDebounceTimeMax + ") is lesser than value of metricDebounceTimeMin (" + config.metricDebounceTimeMin + ")");
        }
        this.sdkToken = config.sdkAuthToken;
        this.log = logger === null || logger === void 0 ? void 0 : logger.log(DEBUG_NAMESPACE);
        if (superJson) {
            this.configHash = utils_1.hashSuperJson(superJson, crypto);
            this.anonymizedSuperJson = utils_1.anonymizeSuperJson(superJson);
        }
    }
    MetricReporter.prototype.reportEvent = function (event) {
        switch (event.eventType) {
            case 'SDKInit':
                this.reportSdkInitEvent(event);
                break;
            case 'PerformMetrics':
                this.reportPerformMetricsEvent(event);
                break;
            case 'ProviderChange':
                this.reportProviderChangeEvent(event);
                break;
        }
    };
    MetricReporter.prototype.flush = function () {
        var metrics = this.aggregateMetrics();
        if (metrics === undefined) {
            return;
        }
        this.performMetrics = [];
        this.startTime = undefined;
        if (this.timer !== undefined) {
            this.timers.clearTimeout(this.timer);
        }
        this.timer = undefined;
        this.sendEvent(metrics);
    };
    // Sets debounce timer, unless maximum debounce time elapsed
    MetricReporter.prototype.setTimer = function () {
        var _this = this;
        var now = this.timers.now();
        var timeHasElapsed = this.startTime !== undefined &&
            now - this.startTime >= this.config.metricDebounceTimeMax;
        // If this is the first request in a batch, set the batch start time for max debounce
        if (this.startTime === undefined) {
            this.startTime = now;
        }
        // If the max debounce time elapsed, do nothing - let the timer execute
        if (timeHasElapsed) {
            return;
        }
        // If the debounce time did not elapse, remove previous set timer
        if (this.timer !== undefined) {
            this.timers.clearTimeout(this.timer);
        }
        // Set the timer for min debounce time - it will execute unless another metric request comes
        this.timer = this.timers.setTimeout(function () {
            _this.flush();
        }, this.config.metricDebounceTimeMin);
    };
    MetricReporter.prototype.reportSdkInitEvent = function (event) {
        this.sendEvent(this.createSDKInitEventPayload(event));
    };
    MetricReporter.prototype.reportPerformMetricsEvent = function (_a) {
        var _ = _a.eventType, metrics = __rest(_a, ["eventType"]);
        this.performMetrics.push(metrics);
        this.setTimer();
    };
    MetricReporter.prototype.reportProviderChangeEvent = function (event) {
        this.sendEvent(this.createProviderChangeEventPayload(event));
    };
    MetricReporter.prototype.createSDKInitEventPayload = function (input) {
        return {
            event_type: 'SDKInit',
            occurred_at: input.occurredAt.toISOString(),
            configuration_hash: this.configHash,
            data: {
                configuration: this.anonymizedSuperJson,
            },
        };
    };
    MetricReporter.prototype.createProviderChangeEventPayload = function (input) {
        var _a;
        return {
            event_type: 'ProviderChange',
            occurred_at: input.occurredAt.toISOString(),
            configuration_hash: this.configHash,
            data: {
                profile: input.profile,
                from_provider: input.from,
                to_provider: input.to,
                failover_reasons: (_a = input.reasons) === null || _a === void 0 ? void 0 : _a.map(function (reason) { return ({
                    reason: failurePolicyReasonToFailoverReason(reason.reason),
                    occurred_at: reason.occurredAt.toISOString(),
                }); }),
            },
        };
    };
    MetricReporter.prototype.aggregateMetrics = function () {
        var e_1, _a;
        if (this.performMetrics.length === 0) {
            return undefined;
        }
        var metrics = [];
        var dates = this.performMetrics.map(function (metric) { return metric.occurredAt; }).sort();
        var from = dates[0].toISOString();
        var to = dates[dates.length - 1].toISOString();
        var profileProviders = this.performMetrics
            .map(function (metric) { return [metric.profile, metric.provider]; })
            .filter(function (_a, index, array) {
            var _b = __read(_a, 2), profile = _b[0], provider = _b[1];
            return array.findIndex(function (_a) {
                var _b = __read(_a, 2), prof = _b[0], prov = _b[1];
                return prof === profile && prov === provider;
            }) === index;
        });
        var _loop_1 = function (profile, provider) {
            var profileProviderMetrics = this_1.performMetrics.filter(function (metric) { return metric.profile === profile && metric.provider === provider; });
            var successes = profileProviderMetrics.filter(function (metric) { return metric.success; }).length;
            var failures = profileProviderMetrics.length - successes;
            metrics.push({
                type: 'PerformMetrics',
                profile: profile,
                provider: provider,
                successful_performs: successes,
                failed_performs: failures,
            });
        };
        var this_1 = this;
        try {
            for (var profileProviders_1 = __values(profileProviders), profileProviders_1_1 = profileProviders_1.next(); !profileProviders_1_1.done; profileProviders_1_1 = profileProviders_1.next()) {
                var _b = __read(profileProviders_1_1.value, 2), profile = _b[0], provider = _b[1];
                _loop_1(profile, provider);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (profileProviders_1_1 && !profileProviders_1_1.done && (_a = profileProviders_1.return)) _a.call(profileProviders_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            event_type: 'Metrics',
            occurred_at: new Date(this.timers.now()).toISOString(),
            configuration_hash: this.configHash,
            data: {
                from: from,
                to: to,
                metrics: metrics,
            },
        };
    };
    // TODO: move this to other http calls
    MetricReporter.prototype.sendEvent = function (payload) {
        var _this = this;
        var url = new URL('/insights/sdk_event', this.config.superfaceApiUrl)
            .href;
        void this.fetchInstance
            .fetch(url, {
            method: 'POST',
            body: interpreter_1.stringBody(JSON.stringify(payload)),
            headers: __assign({ 'content-type': interpreter_1.JSON_CONTENT }, (this.sdkToken !== undefined
                ? { authorization: "SUPERFACE-SDK-TOKEN " + this.sdkToken }
                : {})),
        })
            .then(function (result) {
            var _a;
            (_a = _this.log) === null || _a === void 0 ? void 0 : _a.call(_this, 'Succesfully sent metrics. Sent: %O', payload.data, 'Response: %O', result);
        })
            .catch(function (error) {
            var _a;
            (_a = _this.log) === null || _a === void 0 ? void 0 : _a.call(_this, 'Unsuccesfully tried to send metrics: %O', error);
        });
    };
    return MetricReporter;
}());
exports.MetricReporter = MetricReporter;
//# sourceMappingURL=reporter.js.map