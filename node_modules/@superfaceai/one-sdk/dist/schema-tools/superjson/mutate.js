"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setPriority = exports.mergeSecurity = exports.swapProviderVariant = exports.setProvider = exports.mergeProvider = exports.swapProfileProviderVariant = exports.setProfileProvider = exports.mergeProfileProvider = exports.setProfile = exports.mergeProfile = exports.mergeProfileDefaults = void 0;
var ast_1 = require("@superfaceai/ast");
var lib_1 = require("../../lib");
var errors_helpers_1 = require("./errors.helpers");
var normalize_1 = require("./normalize");
var utils_1 = require("./utils");
/** Merges profile defaults into the document or creates the profile if it doesn't exist. */
function mergeProfileDefaults(document, profileName, payload) {
    // if specified profile is not found
    if (document.profiles === undefined) {
        document.profiles = {};
    }
    if (document.profiles[profileName] === undefined) {
        document.profiles[profileName] = '0.0.0';
    }
    var targetedProfile = document.profiles[profileName];
    // if specified profile has shorthand notation
    var defaults;
    if (typeof targetedProfile === 'string') {
        defaults = payload;
        if (ast_1.isVersionString(targetedProfile)) {
            document.profiles[profileName] = {
                version: targetedProfile,
                defaults: defaults,
            };
            return true;
        }
        if (ast_1.isFileURIString(targetedProfile)) {
            document.profiles[profileName] = {
                file: targetedProfile,
                defaults: defaults,
            };
            return true;
        }
    }
    else {
        if (targetedProfile.defaults === undefined) {
            document.profiles[profileName] = __assign(__assign({}, targetedProfile), { defaults: payload });
            return true;
        }
        else {
            // Merge existing with new
            defaults = lib_1.mergeVariables(lib_1.castToNonPrimitive(targetedProfile.defaults), lib_1.castToNonPrimitive(payload));
            document.profiles[profileName] = __assign(__assign({}, targetedProfile), { defaults: defaults });
            return true;
        }
    }
    return false;
}
exports.mergeProfileDefaults = mergeProfileDefaults;
/** Merges profile into the document or creates it if it doesn't exist. */
function mergeProfile(document, profileName, payload, filesystem, environment, logger) {
    var _a;
    var _b, _c, _d, _e, _f;
    // if specified profile is not found
    if (document.profiles === undefined ||
        document.profiles[profileName] === undefined) {
        document.profiles = __assign(__assign({}, document.profiles), (_a = {}, _a[profileName] = payload, _a));
        return true;
    }
    var targetedProfile = document.profiles[profileName];
    // Priority #1: shorthand notation - file URI or semantic version
    if (typeof payload === 'string') {
        var isShorthandAvailable = typeof targetedProfile === 'string' ||
            (lib_1.isEmptyRecord((_b = targetedProfile.defaults) !== null && _b !== void 0 ? _b : {}) &&
                lib_1.isEmptyRecord((_c = targetedProfile.providers) !== null && _c !== void 0 ? _c : {}));
        var commonProperties = {};
        if (typeof targetedProfile !== 'string') {
            if (targetedProfile.providers) {
                commonProperties.providers = targetedProfile.providers;
            }
            if (targetedProfile.defaults) {
                commonProperties.defaults = targetedProfile.defaults;
            }
        }
        // when specified profile is file URI in shorthand notation
        if (ast_1.isFileURIString(payload)) {
            if (isShorthandAvailable) {
                document.profiles[profileName] = utils_1.composeFileURI(payload, filesystem.path.normalize);
                return true;
            }
            document.profiles[profileName] = __assign({ file: filesystem.path.normalize(utils_1.trimFileURI(payload)) }, commonProperties);
            return true;
        }
        // when specified profile is version in shorthand notation
        if (ast_1.isVersionString(payload)) {
            if (isShorthandAvailable) {
                document.profiles[profileName] = payload;
                return true;
            }
            document.profiles[profileName] = __assign({ version: payload }, commonProperties);
            return true;
        }
        throw new lib_1.UnexpectedError('Invalid string payload format');
    }
    // Priority #2: keep previous structure and merge
    var defaults;
    var priority;
    if (typeof targetedProfile === 'string') {
        defaults = payload.defaults;
    }
    else {
        if (targetedProfile.defaults) {
            if (!payload.defaults) {
                defaults = targetedProfile.defaults;
            }
            else {
                // Merge existing with new
                defaults = lib_1.mergeVariables(lib_1.castToNonPrimitive((_d = targetedProfile.defaults) !== null && _d !== void 0 ? _d : {}), lib_1.castToNonPrimitive((_e = payload.defaults) !== null && _e !== void 0 ? _e : {}));
            }
        }
        if (targetedProfile.priority) {
            priority = targetedProfile.priority;
        }
    }
    var providers;
    if (typeof targetedProfile === 'string') {
        providers = payload.providers;
    }
    else if (targetedProfile.providers) {
        Object.entries((_f = payload.providers) !== null && _f !== void 0 ? _f : {}).forEach(function (_a) {
            var _b = __read(_a, 2), providerName = _b[0], entry = _b[1];
            return mergeProfileProvider(document, profileName, providerName, entry, filesystem, environment, logger);
        });
        providers = targetedProfile.providers;
    }
    document.profiles[profileName] = __assign(__assign({}, payload), { priority: priority, defaults: defaults, providers: providers });
    return true;
}
exports.mergeProfile = mergeProfile;
function resolvePriorityAddition(existingPriority, newProvider) {
    if (!existingPriority || existingPriority.length === 0) {
        return [newProvider];
    }
    if (!existingPriority.includes(newProvider)) {
        return __spreadArray(__spreadArray([], __read(existingPriority)), [newProvider]);
    }
    return existingPriority;
}
/** Sets profile of the document to payload or deletes it. */
function setProfile(document, profileName, payload, environment, filesystem, logger) {
    var changed = false;
    // delete any existing profile
    if (document.profiles !== undefined && profileName in document.profiles) {
        changed = true;
        delete document.profiles[profileName];
        if (Object.keys(document.profiles).length === 0) {
            delete document.profiles;
        }
    }
    // if payload is undefined we already deleted it (or it wasn't present)
    if (payload !== undefined) {
        var mergeChanged = mergeProfile(document, profileName, payload, filesystem, environment, logger);
        changed = changed || mergeChanged;
    }
    return changed;
}
exports.setProfile = setProfile;
/**
 * Ensure that profile exists (defaults to version '0.0.0') and that its providers key is defined (defaults to empty record).
 */
function ensureProfileWithProviders(document, profileName, environment, logger) {
    var changed = false;
    if (document.profiles === undefined) {
        document.profiles = {};
        changed = true;
    }
    if (document.profiles[profileName] === undefined) {
        document.profiles[profileName] = {
            version: '0.0.0',
            providers: {},
        };
        changed = true;
    }
    var profile = document.profiles[profileName];
    if (typeof profile === 'string') {
        document.profiles[profileName] = normalize_1.normalizeProfileSettings(document.profiles[profileName], [], environment, logger);
        changed = true;
    }
    else if (profile.providers === undefined) {
        profile.providers = {};
        changed = true;
    }
    var ensuredProfile = document.profiles[profileName];
    return [changed, ensuredProfile];
}
/** Merges profile provider into the document or creates the profile and providers object if it doesn't exist. */
function mergeProfileProvider(document, profileName, providerName, payload, fileSystem, environment, logger) {
    var _a;
    var _b, _c, _d, _e, _f;
    var _g = __read(ensureProfileWithProviders(document, profileName, environment, logger), 2), _ = _g[0], targetProfile = _g[1];
    void _;
    var profileProvider = (_b = targetProfile.providers) === null || _b === void 0 ? void 0 : _b[providerName];
    // if specified profile provider is not found
    if (profileProvider === undefined ||
        ((_c = targetProfile.providers) === null || _c === void 0 ? void 0 : _c[providerName]) === undefined) {
        targetProfile.providers = __assign(__assign({}, targetProfile.providers), (_a = {}, _a[providerName] = payload, _a));
        targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
        return true;
    }
    // Priority #1: shorthand notation - file URI
    // when specified profile provider is file URI shorthand notation
    if (typeof payload === 'string') {
        if (typeof profileProvider === 'string' ||
            lib_1.isEmptyRecord((_d = profileProvider.defaults) !== null && _d !== void 0 ? _d : {})) {
            targetProfile.providers[providerName] = utils_1.composeFileURI(payload, fileSystem.path.normalize);
            targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
            return true;
        }
        targetProfile.providers[providerName] = {
            file: fileSystem.path.normalize(utils_1.trimFileURI(payload)),
            defaults: profileProvider.defaults,
        };
        targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
        return true;
    }
    // Priority #2: keep previous structure and merge
    var defaults;
    if (typeof profileProvider === 'string') {
        // Change
        defaults = payload.defaults;
    }
    else {
        if (profileProvider.defaults && payload.defaults) {
            // Change
            // Merge existing with new
            defaults = lib_1.mergeVariables(lib_1.castToNonPrimitive((_e = profileProvider.defaults) !== null && _e !== void 0 ? _e : {}), lib_1.castToNonPrimitive((_f = payload.defaults) !== null && _f !== void 0 ? _f : {}));
        }
        else if (!profileProvider.defaults && payload.defaults) {
            defaults = payload.defaults;
        }
    }
    // if there no other keys and we changed defaults
    if (!('file' in payload) &&
        !('mapVariant' in payload) &&
        !('mapRevision' in payload) &&
        defaults) {
        targetProfile.providers[providerName] = __assign(__assign({}, (typeof profileProvider === 'string'
            ? { file: profileProvider }
            : profileProvider)), { defaults: defaults });
        targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
        return true;
    }
    // when specified profile provider has file & defaults
    if ('file' in payload) {
        targetProfile.providers[providerName] = __assign(__assign({}, payload), { defaults: defaults });
        targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
        return true;
    }
    // when specified profile provider has mapVariant, mapRevision & defaults
    if ('mapVariant' in payload || 'mapRevision' in payload) {
        if (typeof profileProvider === 'string') {
            targetProfile.providers[providerName] = __assign(__assign({}, payload), { defaults: defaults });
            targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
            return true;
        }
        var mapProperties = 'file' in profileProvider ? {} : profileProvider;
        if (payload.mapVariant !== undefined) {
            mapProperties.mapVariant = payload.mapVariant;
        }
        if (payload.mapRevision !== undefined) {
            mapProperties.mapRevision = payload.mapRevision;
        }
        targetProfile.providers[providerName] = __assign(__assign({}, mapProperties), { defaults: defaults });
        targetProfile.priority = resolvePriorityAddition(targetProfile.priority, providerName);
        return true;
    }
    return false;
}
exports.mergeProfileProvider = mergeProfileProvider;
/** Sets profile provider of the document to payload or deletes it. */
function setProfileProvider(document, profileName, providerName, payload, filesystem, environment, logger) {
    var changed = false;
    // delete any existing profile provider
    if (document.profiles !== undefined && profileName in document.profiles) {
        var profile = document.profiles[profileName];
        if (typeof profile !== 'string' &&
            profile.providers !== undefined &&
            providerName in profile.providers) {
            changed = true;
            delete profile.providers[providerName];
            // remove from priority, but only if we are actually deleting
            // otherwise preserve the priority order
            if (payload === undefined) {
                if (profile.priority !== undefined) {
                    var index = profile.priority.indexOf(providerName);
                    if (index >= 0) {
                        profile.priority.splice(index, 1);
                    }
                    if (profile.priority.length === 0) {
                        delete profile.priority;
                    }
                }
            }
            if (Object.keys(profile.providers).length === 0) {
                delete profile.providers;
            }
        }
    }
    // if payload is undefined we already deleted it (or it wasn't present)
    if (payload !== undefined) {
        var mergeChanged = mergeProfileProvider(document, profileName, providerName, payload, filesystem, environment, logger);
        changed = changed || mergeChanged;
    }
    return changed;
}
exports.setProfileProvider = setProfileProvider;
function swapProfileProviderVariant(document, profileName, providerName, variant, filesystem, environment, logger) {
    var _a = __read(ensureProfileWithProviders(document, profileName, environment, logger), 2), _ = _a[0], targetProfile = _a[1];
    void _;
    var changed = false;
    var targetProfileProvider = targetProfile.providers[providerName];
    if (variant.kind === 'local') {
        if (typeof targetProfileProvider === 'string') {
            // "provider": "path/to/map"
            changed =
                utils_1.composeFileURI(variant.file, filesystem.path.normalize) ===
                    targetProfileProvider;
            targetProfileProvider = utils_1.composeFileURI(variant.file, filesystem.path.normalize);
        }
        else if (targetProfileProvider === undefined ||
            targetProfileProvider.defaults === undefined ||
            Object.keys(targetProfileProvider.defaults).length === 0) {
            // "provider": { "file": "path/to/map" } | {}
            changed =
                targetProfileProvider === undefined ||
                    !('file' in targetProfileProvider &&
                        targetProfileProvider.file === variant.file);
            targetProfileProvider = utils_1.composeFileURI(variant.file, filesystem.path.normalize);
        }
        else {
            // "provider": { "file": "path/to/map", "defaults": <non-empty> } | { "defaults": <non-empty> }
            changed = !('file' in targetProfileProvider &&
                targetProfileProvider.file === variant.file);
            targetProfileProvider = {
                file: variant.file,
                defaults: targetProfileProvider.defaults,
            };
        }
    }
    else if (variant.kind === 'remote') {
        if (targetProfileProvider === undefined ||
            typeof targetProfileProvider === 'string') {
            changed = true;
            targetProfileProvider = {
                mapVariant: variant.mapVariant,
                mapRevision: variant.mapRevision,
            };
        }
        else if ('file' in targetProfileProvider) {
            changed = true;
            targetProfileProvider = {
                mapVariant: variant.mapVariant,
                mapRevision: variant.mapRevision,
                defaults: targetProfileProvider.defaults,
            };
        }
        else {
            changed =
                targetProfileProvider.mapVariant !== variant.mapVariant ||
                    targetProfileProvider.mapRevision !== variant.mapRevision;
            targetProfileProvider = {
                mapVariant: variant.mapVariant,
                mapRevision: variant.mapRevision,
                defaults: targetProfileProvider.defaults,
            };
        }
    }
    if (changed) {
        targetProfile.providers[providerName] = targetProfileProvider;
    }
    return changed;
}
exports.swapProfileProviderVariant = swapProfileProviderVariant;
/** Merges provider into the document or creates it if it doesn't exist. */
function mergeProvider(document, providerName, payload, filesystem) {
    var _a, _b, _c, _d;
    if (document.providers === undefined) {
        document.providers = {};
    }
    var targetProvider = (_a = document.providers[providerName]) !== null && _a !== void 0 ? _a : {};
    if (typeof payload === 'string') {
        var isShorthandAvailable = typeof targetProvider === 'string' ||
            targetProvider.security === undefined ||
            targetProvider.security.length === 0 ||
            targetProvider.parameters === undefined ||
            Object.keys(targetProvider.parameters).length === 0;
        if (ast_1.isFileURIString(payload)) {
            if (isShorthandAvailable) {
                document.providers[providerName] = utils_1.composeFileURI(payload, filesystem.path.normalize);
            }
            else {
                document.providers[providerName] = {
                    file: filesystem.path.normalize(utils_1.trimFileURI(payload)),
                    // has to be an object because isShorthandAvailable is false
                    security: targetProvider.security,
                    parameters: targetProvider.parameters,
                };
            }
            return true;
        }
        throw new lib_1.UnexpectedError('Invalid string payload format');
    }
    if (typeof targetProvider === 'string') {
        document.providers[providerName] = __assign({ file: targetProvider }, payload);
    }
    else {
        var provider = {};
        if (payload.file !== undefined || targetProvider.file !== undefined) {
            provider.file = (_b = payload.file) !== null && _b !== void 0 ? _b : targetProvider.file;
        }
        if (targetProvider.security !== undefined ||
            payload.security !== undefined) {
            provider.security = mergeSecurity((_c = targetProvider.security) !== null && _c !== void 0 ? _c : [], (_d = payload.security) !== null && _d !== void 0 ? _d : []);
        }
        if (targetProvider.parameters !== undefined ||
            payload.parameters !== undefined) {
            provider.parameters = Object.assign(targetProvider.parameters || {}, payload.parameters || {});
        }
        document.providers[providerName] = provider;
    }
    return true;
}
exports.mergeProvider = mergeProvider;
/** Sets provider of the document to payload or deletes it. */
function setProvider(document, providerName, payload, filesystem) {
    var changed = false;
    // delete any existing provider
    if (document.providers !== undefined && providerName in document.providers) {
        changed = true;
        delete document.providers[providerName];
        if (Object.keys(document.providers).length === 0) {
            delete document.providers;
        }
    }
    // if payload is undefined we already deleted it (or it wasn't present)
    if (payload !== undefined) {
        var mergeChanged = mergeProvider(document, providerName, payload, filesystem);
        changed = changed || mergeChanged;
    }
    return changed;
}
exports.setProvider = setProvider;
function swapProviderVariant(document, providerName, variant, filesystem) {
    if (document.providers === undefined) {
        document.providers = {};
    }
    var changed = false;
    var targetProvider = document.providers[providerName];
    if (variant.kind === 'local') {
        if (typeof targetProvider === 'string') {
            changed =
                utils_1.composeFileURI(variant.file, filesystem.path.normalize) !==
                    targetProvider;
            targetProvider = utils_1.composeFileURI(variant.file, filesystem.path.normalize);
        }
        else if (targetProvider === undefined ||
            targetProvider.security === undefined ||
            targetProvider.security.length === 0) {
            changed = true;
            targetProvider = utils_1.composeFileURI(variant.file, filesystem.path.normalize);
        }
        else {
            changed = variant.file !== targetProvider.file;
            targetProvider.file = variant.file;
        }
    }
    else if (variant.kind === 'remote') {
        if (typeof targetProvider === 'string' || targetProvider === undefined) {
            changed = true;
            targetProvider = {};
        }
        else if ('file' in targetProvider) {
            changed = true;
            delete targetProvider.file;
        }
    }
    if (changed) {
        document.providers[providerName] = targetProvider;
    }
    return changed;
}
exports.swapProviderVariant = swapProviderVariant;
function mergeSecurity(left, right) {
    var e_1, _a, e_2, _b;
    var result = [];
    try {
        for (var left_1 = __values(left), left_1_1 = left_1.next(); !left_1_1.done; left_1_1 = left_1.next()) {
            var entry = left_1_1.value;
            result.push(entry);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (left_1_1 && !left_1_1.done && (_a = left_1.return)) _a.call(left_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_1 = function (entry) {
        var index = result.findIndex(function (item) { return item.id === entry.id; });
        if (index !== -1) {
            result[index] = entry;
        }
        else {
            result.push(entry);
        }
    };
    try {
        for (var right_1 = __values(right), right_1_1 = right_1.next(); !right_1_1.done; right_1_1 = right_1.next()) {
            var entry = right_1_1.value;
            _loop_1(entry);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (right_1_1 && !right_1_1.done && (_b = right_1.return)) _b.call(right_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
}
exports.mergeSecurity = mergeSecurity;
/** Sets priority array to the new values. */
function setPriority(document, profileName, providersSortedByPriority, environment, logger) {
    var _a, _b;
    if (document.profiles === undefined) {
        document.profiles = {};
    }
    if (document.profiles[profileName] === undefined) {
        return lib_1.err(errors_helpers_1.profileNotFoundError(profileName));
    }
    var targetedProfile = document.profiles[profileName];
    // if specified profile has shorthand notation
    if (typeof targetedProfile === 'string') {
        document.profiles[profileName] = targetedProfile = normalize_1.normalizeProfileSettings(targetedProfile, Object.keys((_a = document.providers) !== null && _a !== void 0 ? _a : {}), environment, logger);
    }
    // check profile providers property
    var profileProviders = targetedProfile.providers;
    if (!profileProviders) {
        return lib_1.err(errors_helpers_1.providersNotSetError(profileName));
    }
    if (providersSortedByPriority === undefined) {
        delete targetedProfile.priority;
        return lib_1.ok(true);
    }
    if (providersSortedByPriority.some(function (p) { return profileProviders[p] === undefined; })) {
        return lib_1.err(errors_helpers_1.providersNotSetError(profileName));
    }
    // check providers property
    var providers = document.providers;
    if (!providers) {
        return lib_1.err(errors_helpers_1.providersNotSetError(profileName));
    }
    if (providersSortedByPriority.some(function (p) { return providers[p] === undefined; })) {
        return lib_1.err(errors_helpers_1.providersNotSetError(profileName));
    }
    // check existing priority array
    var existingPriority = (_b = targetedProfile.priority) !== null && _b !== void 0 ? _b : [];
    // Arrays are same
    if (providersSortedByPriority.length === existingPriority.length &&
        providersSortedByPriority.every(function (value, index) { return value === existingPriority[index]; })) {
        return lib_1.ok(false);
    }
    targetedProfile.priority = providersSortedByPriority;
    return lib_1.ok(true);
}
exports.setPriority = setPriority;
//# sourceMappingURL=mutate.js.map