"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailurePolicy = exports.FailurePolicyReason = void 0;
var lib_1 = require("../../../lib");
var FailurePolicyReason = /** @class */ (function () {
    function FailurePolicyReason(data) {
        this.data = data;
        this.prefixMessages = [];
    }
    FailurePolicyReason.fromExecutionFailure = function (failure) {
        return new FailurePolicyReason({ kind: 'failure', failure: failure });
    };
    FailurePolicyReason.fromPolicyReason = function (reason) {
        return new FailurePolicyReason({ kind: 'policy', reason: reason });
    };
    FailurePolicyReason.prototype.addPrefixMessage = function (message) {
        this.prefixMessages.unshift(message);
        return this;
    };
    Object.defineProperty(FailurePolicyReason.prototype, "message", {
        get: function () {
            return this.toString();
        },
        enumerable: false,
        configurable: true
    });
    FailurePolicyReason.prototype.toString = function () {
        var prefix = this.prefixMessages.join(': ');
        if (this.data.kind === 'failure') {
            return "[" + new Date(this.data.failure.time).toISOString() + "] " + prefix + ": " + FailurePolicyReason.failureToString(this.data.failure);
        }
        else {
            return prefix + ": " + this.data.reason;
        }
    };
    FailurePolicyReason.prototype.toError = function () {
        switch (this.data.kind) {
            case 'failure':
                return new lib_1.SDKExecutionError(FailurePolicyReason.failureToString(this.data.failure), [
                    "At " + new Date(this.data.failure.time).toISOString(),
                    this.prefixMessages.join(': '),
                ], []);
            case 'policy':
                return new lib_1.SDKExecutionError("Failure policy aborted with reason:' " + this.data.reason, [this.prefixMessages.join(': ')], ['Check that the failure policy is correctly configured']);
        }
    };
    FailurePolicyReason.failureToString = function (failure) {
        if (failure.kind === 'http') {
            return "Request ended with " + failure.kind + " error, status code: " + failure.response.statusCode;
        }
        else if (failure.kind === 'request' || failure.kind === 'network') {
            return "Request ended with " + failure.kind + " error: " + failure.issue;
        }
        else {
            return "Request ended with error: " + failure.originalError.toString();
        }
    };
    return FailurePolicyReason;
}());
exports.FailurePolicyReason = FailurePolicyReason;
/**
 * Failure policy governs the behavior of SDK in face of execution (perform) failures.
 *
 * The task of this policy is to decide when to repeat a usecase perform, when to failover to a different provider
 * or when to reattempt going back to the original provider.
 *
 * Each instance of failure policy is associated with one instance of a client and one specific usecase for that client.
 * A such, an instance of policy can hold the state required to make future decitions based on any past events.
 *
 * The overall cycle is the following:
 * 1. The user requests a usecase perform
 * 2. Failure policy `beforeExecution` is called
 *     - May abort the execution
 *     - May specify a timeout or failover reattempt
 *     - May request a recache
 * 3. A bind is executed if it is not cached yet
 * 4. The usecase is performed
 * 5. If failed - `afterFailue` is called
 *     - May abort the execution
 *     - May retry, failover, etc. jumping back to 2.
 * 6. If succeeded  - `afterSuccess` is called, cycle ends
 */
var FailurePolicy = /** @class */ (function () {
    function FailurePolicy(usecaseInfo) {
        this.usecaseInfo = usecaseInfo;
    }
    return FailurePolicy;
}());
exports.FailurePolicy = FailurePolicy;
//# sourceMappingURL=policy.js.map