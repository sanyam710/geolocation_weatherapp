interface IResult<T, E> {
    /** Returns `true` if this result represents an `Ok variant. */
    isOk(): this is Ok<T, E>;
    /** Returns `true` if this result represents an `Err` variant. */
    isErr(): this is Err<T, E>;
    /** Maps `Ok` variant and propagates `Err` variant. */
    map<U>(f: (t: T) => U): Result<U, E>;
    /** Maps `Err` variant and propagates `Ok` variant. */
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    /** Fallibly maps `Ok` variant and propagates `Err` variant. */
    andThen<U>(f: (t: T) => Result<U, E>): Result<U, E>;
    /** Calls `ok` if `this` is `Ok` variant and `err` if `this` is `Err` variant. */
    match<U>(ok: (t: T) => U, err: (e: E) => U): U;
    /** Unwraps `Ok` variant and throws on `Err` variant. */
    unwrap(): T;
}
interface IAsyncResult<T, E> {
    /** Maps `Ok` variant asynchronously and propagates `Err` variant. */
    mapAsync<U>(f: (t: T) => Promise<U>): Promise<Result<U, E>>;
    /** Maps `Err` variant asynchronously and propagates `Ok` variant. */
    mapErrAsync<U>(f: (t: E) => Promise<U>): Promise<Result<T, U>>;
    /** Fallibly maps `Ok` variant asynchronously and propagates `Err` variant. */
    andThenAsync<U>(f: (t: T) => Promise<Result<U, E>>): Promise<Result<U, E>>;
}
export declare class Ok<T, E> implements IResult<T, E>, IAsyncResult<T, E> {
    readonly value: T;
    constructor(value: T);
    isOk(): this is Ok<T, E>;
    isErr(): this is Err<T, E>;
    map<U>(f: (t: T) => U): Result<U, E>;
    mapErr<U>(_: (e: E) => U): Result<T, U>;
    andThen<U>(f: (t: T) => Result<U, E>): Result<U, E>;
    match<U>(ok: (t: T) => U, _: (e: E) => U): U;
    unwrap(): T;
    mapAsync<U>(f: (t: T) => Promise<U>): Promise<Result<U, E>>;
    mapErrAsync<U>(_: (t: E) => Promise<U>): Promise<Result<T, U>>;
    andThenAsync<U>(f: (t: T) => Promise<Result<U, E>>): Promise<Result<U, E>>;
}
export declare class Err<T, E> implements IResult<T, E>, IAsyncResult<T, E> {
    readonly error: E;
    constructor(error: E);
    isOk(): this is Ok<T, E>;
    isErr(): this is Err<T, E>;
    map<U>(_: (t: T) => U): Result<U, E>;
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    andThen<U>(_: (t: T) => Result<U, E>): Result<U, E>;
    match<U>(_: (t: T) => U, err: (e: E) => U): U;
    unwrap(): T;
    mapAsync<U>(_: (t: T) => Promise<U>): Promise<Result<U, E>>;
    mapErrAsync<U>(f: (t: E) => Promise<U>): Promise<Result<T, U>>;
    andThenAsync<U>(_: (t: T) => Promise<Result<U, E>>): Promise<Result<U, E>>;
}
export declare type Result<T, E> = Ok<T, E> | Err<T, E>;
export declare const ok: <T, E>(value: T) => Ok<T, E>;
export declare const err: <T, E>(err: E) => Err<T, E>;
export {};
